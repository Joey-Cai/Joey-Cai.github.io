---
layout: post
title: "链表的基础知识"
categories: Data-Structure
tags: LinkList
auther: Joey
---

# 链表

* 缓存淘汰策略

  * FIFO(First In, First Out)
  * LFU(Least Frequently Used)
  * LRU(Least Recently Used)

  ***

* 如何用链表实现LRU缓存淘汰策略？

  > 我的想法：
  >
  > 1. 将缓存数据存到一个双向链表中
  > 2. 当缓存中的数据被使用时，将其插入到链表的头部
  > 3. 当缓存被用满时，将链表尾部的元素清理出去，即：当有心数据进入缓存时，将其插到链表头部即可。

  ***

* 顺序表存储密度高，但由于其需要连续的存储空间，对内存的要求也比较高，在申请内存时容易申请失败。

* 单链表的随机访问的时间复杂度为O(n)

* 循环链表

  * 优点：从链表到链头比较方便，当处理的数据具有环行结构时，特别适合循环链表
    * 比如：[约瑟夫问题][https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/3857719?fr=aladdin]
    * 题目描述：15个教徒和15 个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了一个办法：30个人围成一圆圈，从第一个人开始依次报数，每数到第九个人就将他扔入大海，如此循环进行直到仅余15个人为止。问怎样排法，才能使每次投入大海的都是非教徒？
    * n个人（编号0~(n-1）），从0开始报数，报到（m-1）的退出，剩下的人继续从0开始报数。求胜利者的编号。
    * ......

  ***

* 双向链表

  * 只是双向遍历，且插入元素和删除元素真正达到O(1)的时间复杂度

* **删除操作**

  **删除某个节点p需要知道其前驱结点q** 

  * 删除给定指针指向结点p的下一个结点

    > p->next=p->next->next; free(p->next);
    >
    > 从而，无论是单链表还是双向链表，其时间复杂度都是O(1)

  * 删除给定指针指向的结点p

    >* 单链表
    >
    >  > 单链表不支持直接获取前驱结点
    >  >
    >  > 从而，单链表须遍历至给定节点的前驱结点，此操作的时间复杂度为O(n)
    >  >
    >  > 删除节点：q->next = p->next; free(p); 此操作时间复杂度为O(1)
    >  >
    >  > 总时间复杂度为O(n)
    >
    >* 双向链表
    >
    >  > p->prior->next = p->next; free(p); 此操作时间复杂度为O(1)

  * 删除结点中“值等于某个给定值”的结点

    >  无论是单链表还是双向链表，都需要进行遍历查找操作，其时间复杂度为O(n)
    >
    > 单纯的删除操作时间复杂度为O(1)
    >
    > 有加法法则得：总时间复杂度为O(n)

  ***

* **插入操作**

  * 在给定指针指向的结点p后插入r

    > r->next = p->next; p->next = r;
    >
    > 从而，无论是单链表还是双向链表，其时间复杂度都是O(1)

  * 在给定指针指向的结点p前插入r

    **需要知道其前驱结点q**

    > * 单链表
    >
    >   > r->next = p; q->next = r; 此操作时间复杂度为O(1)
    >   >
    >   > 然而，在执行上一步操作时，需要获取p的前驱结点q
    >   >
    >   > 而这个过程只能通过遍历，其时间复杂度为O(n)
    >   >
    >   > 有加法法则得：总时间复杂度为O(n)
    >
    > * 双向链表
    >
    >   > r->next = p; p->prior->next = r; 此操作时间复杂度为O(1)

  ***

* **空间换时间**的设计思想
  * 双向链表便是一个例子

* 如何用链表实现LRU缓存淘汰策略？

  > 我们维护一个有序单链表(==为什么是单链表而不是双向链表？==)，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
  >
  > 1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
  >
  > 2. 如果此数据没有在缓存链表中，又可以分为两种情况：
  >    - 如果此时缓存未满，则将此结点直接插入到链表的头部；
  >    - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
  >
  > 高亮部分我的理解：
  >
  > * 缓存中的存储空间大小有限，浪费不得
  > * 缓存的读取速度相对于I/O而言，已经是很快了，在时间复杂度上可以有所宽松



## 思考题

如果字符串是通过单链表来存储的，那么应该如何判断是一个回文串呢？

* 我的思路

  * 快慢指针法

    > 

  